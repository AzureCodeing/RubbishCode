# 二进制中1的个数
[题目连接](https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&tqId=11164&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述
输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。


## 题目要求
时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32M，其他语言64M 热度指数：570185
本题知识点： 进制转化 补码反码原码 

## 解题思路
1. 常规解法:移位，每次左移一位并且与0xfe进行与操作,直到移位数为0
2. 最优解: 整数-1与自己进行与操作，会把最右边的1变为0,一共可以操作多少次就表明二进制有多少个1

0X0F-1  0X0F  

0X0E & 0X0F          1110   1111    0X0E
0X0D & OXOE          1101   1110    0X0C
0X0B & 0X0C   		 1011   11001   0X08
0X07 & 0X08		     0111   1000    0x00

3. 查表法
```
* __lowest_bit_bitmap[] 数组的解析
* 将一个 8 位整形数的取值范围 0~255 作为数组的索引，
* 索引值第一个出现 1(从最低位开始)的位号作为该数组索引下的成员值。
* 举例：十进制数 10 的二进制为： 0000 1010,从最低位开始，
* 第一个出现 1 的位号为 bit1，则有__lowest_bit_bitmap[10]=1
* 注意：只需要找到第一个出现 1 的位号即可
*/
const rt_uint8_t __lowest_bit_bitmap[] =
{ /* 位号 */
/* 00 */ 0, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
/* 10 */ 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
/* 20 */ 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
/* 30 */ 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
/* 40 */ 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
/* 50 */ 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
/* 60 */ 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
/* 70 */ 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
/* 80 */ 7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
/* 90 */ 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
/* A0 */ 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
/* B0 */ 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
/* C0 */ 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
/* D0 */ 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
/* E0 */ 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,
/* F0 */ 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0
}; 

/**
* 该函数用于从一个 32 位的数中寻找第一个被置 1 的位（从低位开始），
* 然后返回该位的索引（即位号）
*
* @return 返回第一个置 1 位的索引号。如果全为 0，则返回 0。
*/
int __rt_ffs(int value)
{
/* 如果值为 0，则直接返回 0 */
if (value == 0) return 0; (1)

/* 检查 bits [07:00]
这里加 1 的原因是避免当第一个置 1 的位是位 0 时
返回的索引号与值都为 0 时返回的索引号重复 */
if (value & 0xff) (2)
return __lowest_bit_bitmap[value & 0xff] + 1;

/* 检查 bits [15:08] */
if (value & 0xff00) (3)
return __lowest_bit_bitmap[(value & 0xff00) >> 8] + 9;
/* 检查 bits [23:16] */
if (value & 0xff0000) (4)
return __lowest_bit_bitmap[(value & 0xff0000) >> 16] + 17;

/* 检查 bits [31:24] */ (5)
return __lowest_bit_bitmap[(value & 0xff000000) >> 24] + 25;
}
```

> 正码码和补码:
> 正数:不变 , 负数:是其正数的反码+1
>> -2 的正数 0000000...10 反码 为 111111....01+1 = 111111111111111

